use schema_bridge::SchemaBridge;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, SchemaBridge)]
struct TestStruct {
    name: String,
    count: i32,
    active: bool,
}

#[derive(Serialize, Deserialize, SchemaBridge)]
enum TestEnum {
    First,
    Second,
    Third,
}

#[derive(Serialize, Deserialize, SchemaBridge)]
struct ComplexStruct {
    id: String,
    values: Vec<i32>,
    optional: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_struct_to_ts() {
        let ts = TestStruct::to_ts();
        assert!(ts.contains("name: string"));
        assert!(ts.contains("count: number"));
        assert!(ts.contains("active: boolean"));
    }

    #[test]
    fn test_enum_to_ts() {
        let ts = TestEnum::to_ts();
        assert!(ts.contains("'First'"));
        assert!(ts.contains("'Second'"));
        assert!(ts.contains("'Third'"));
        assert!(ts.contains("|"));
    }

    #[test]
    fn test_complex_struct_to_ts() {
        let ts = ComplexStruct::to_ts();
        assert!(ts.contains("id: string"));
        assert!(ts.contains("values: number[]"));
        assert!(ts.contains("optional: string | null"));
    }

    #[test]
    fn test_generated_file_format() {
        use schema_bridge::generate_ts_file;

        let types = vec![
            ("TestStruct", TestStruct::to_ts()),
            ("TestEnum", TestEnum::to_ts()),
        ];

        let content = generate_ts_file(types);

        assert!(content.starts_with("// This file is auto-generated by schema-bridge"));
        assert!(content.contains("export type TestStruct ="));
        assert!(content.contains("export type TestEnum ="));
    }
}
